module ch01 where

-- Exercise 1.1. Given functions f : A → B and g : B → C,
-- define their composite g ◦ f : A → C.
-- Show that we have h ◦ ( g ◦ f ) ≡ ( h ◦ g ) ◦ f .
o (A B C : U) (g : B -> C) (f : A -> B) (x : A) : C = g (f x)

oassoc (A B C D : U) (h : C -> D) (g : B -> C) (f : A -> B) :
       -- A -> D = o A C D h (o A B C g f)
       -- A -> D = o A B D (o B C D h g) f
       PathP (<_> A -> D) (o A C D h (o A B C g f)) (o A B D (o B C D h g) f)
       = <i> (o A C D h (o A B C g f))

-- Exercise 1.2. Derive the recursion principle for products rec A × B
-- using only the projections, and verify that the definitional equalities
-- are valid. Do the same for Σ-types.

recsigma (A C : U) (B : A -> U) (g : (x : A) -> B x -> C) (p : (x : A) * B x) : C = g p.1 p.2

recsigmabeta (A C : U) (B : A -> U) (g : (x : A) -> B x -> C)
           (p : (x : A) * B x) : PathP (<_> C) (recsigma A C B g p) (g p.1 p.2) = <i> g p.1 p.2

-- Exercise 1.3. Derive the induction principle for products ind A × B ,
-- using only the projections and the propositional uniqueness principle uniq A × B .
-- Verify that the definitional equalities are valid.
-- Generalize uniq A × B to Σ-types, and do the same for Σ-types.

indsigma (A : U) (B : A -> U) (C: ((x : A) * B x) -> U)
         (g : (a : A) -> (b : B a) -> C (a,b))
         (p : (x : A) * B x)
         : C p = g p.1 p.2

indsigmabeta (A : U) (B : A -> U) (C: ((x : A) * B x) -> U)
           (g : (a : A) -> (b : B a) -> C (a,b))
           (p : (x : A) * B x)
           : PathP (<_> C p) (indsigma A B C g p) (g p.1 p.2)
           = <i> g p.1 p.2

-- Exercise 1.4. Assuming as given only the iterator for natural numbers
-- derive a function having the type of the recursor rec N .
-- Show that the defining equations of the
-- recursor hold propositionally for this function,
-- using the induction principle for N.

data nat = zero | succ (n : nat)
data x (A B : U) = tuple (a : A) (b : B)
fst (A B : U) : (x A B) -> A = split tuple a _ -> a
snd (A B : U) : (x A B) -> B = split tuple _ b -> b

recN (C : U) (c0 : C) (cs : nat -> C -> C) : nat -> C = split
     zero -> c0
     succ n -> cs n (recN C c0 cs n)

indN (C : nat -> U) (c0 : C zero)
     (cs : (n : nat) -> C n -> C (succ n))
     : (n : nat) -> C n = split
     zero -> c0
     succ n -> cs n (indN C c0 cs n)

iter (C : U) (c0 : C) (cs : C -> C) : nat -> C = split
     zero -> c0
     succ n -> cs (iter C c0 cs n)

frecN (C : U) (c0 : C) (cs : nat -> C -> C) (n : nat) : C =
      snd nat C (iter (x nat C) c0' cs' n) where
      c0' : (x nat C) = tuple zero c0
      cs' : (x nat C) -> (x nat C)
          = split tuple n' c -> tuple (succ n') (cs n' c)

P (C : U) (n : nat) : U = x nat C

ex1_4_1 (C' : U) (c0 : C') (cs : nat -> C' -> C') (n : nat) : x nat C' =
        indN C (tuple zero c0)
        (\(n : nat) -> \(q : C n) -> tuple (succ (fst q)) (cs (fst q) (snd q))) n
        where
          C : nat -> U = P C'

